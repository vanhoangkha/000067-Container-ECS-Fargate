[
{
	"uri": "/vi/3-containersanddocker/3.1-dockerbasic/",
	"title": "Docker cơ bản",
	"tags": [],
	"description": "",
	"content": "Docker cơ bản Tổng quan Docker là nền tảng phần mềm cho phép bạn dựng, kiểm thử và triển khai ứng dụng một cách nhanh chóng. Docker đóng gói phần mềm vào các đơn vị tiêu chuẩn hóa được gọi là container có mọi thứ mà phần mềm cần để chạy, trong đó có thư viện, công cụ hệ thống, mã và thời gian chạy. Bằng cách sử dụng Docker, bạn có thể nhanh chóng triển khai và thay đổi quy mô ứng dụng vào bất kỳ môi trường nào và biết chắc rằng mã của bạn sẽ chạy được. Việc chạy Docker trên AWS đem đến cho các nhà phát triển và quản trị viên một phương thức dựng, vận chuyển và chạy ứng dụng phân phối ở quy mô bất kỳ có chi phí thấp và độ tin cậy cao.\nDocker hợp tác với AWS để hỗ trợ các nhà phát triển nhanh chóng đưa ứng dụng hiện đại lên đám mây. Sự hợp tác này giúp nhà phát triển sử dụng Docker Compose và Docker Desktop để tận dụng cùng một quy trình làm việc cục bộ mà họ sử dụng ngày nay để triển khai các ứng dụng trên Amazon ECS và AWS Fargate một cách liền mạch.\n\rCách thức hoạt động của Docker Docker hoạt động bằng cách cung cấp phương thức tiêu chuẩn để chạy mã của bạn. Docker là hệ điều hành dành cho container. Cũng tương tự như cách máy ảo ảo hóa (loại bỏ nhu cầu quản lý trực tiếp) phần cứng máy chủ, các container sẽ ảo hóa hệ điều hành của máy chủ. Docker được cài đặt trên từng máy chủ và cung cấp các lệnh đơn giản mà bạn có thể sử dụng để dựng, khởi động hoặc dừng container.\nCác dịch vụ AWS như AWS Fargate, Amazon ECS, Amazon EKS và AWS Batch giúp bạn dễ dàng chạy các container Docker ở quy mô lớn.\nTrong bài lab, chúng ta thực hiện các lệnh cơ bản Docker với AWS Cloud9\n Kiểm tra client và server đang hoạt động bằng lệnh:  docker --version Docker container được xây dựng từ image.   Lệnh pull  docker pull [OPTIONS] NAME[:TAG|@DIGEST]  Trước hết, chúng ta sử dụng lệnh docker pull nginx:latest để kéo nginx image mới nhất từ Docker Hub.  docker pull nginx\\:latest Để kiểm tra kéo image về thành công(image sẽ nằm trong local machine Docker cache).   Usage  docker images [OPTIONS] [REPOSITORY[:TAG]]  Mục đích liệt kê danh sách các image.  docker images Docker Daemon đóng vai trò server, nhận các RESTful requests từ Docker Client và thực thi.   Chúng ta sử dụng lệnh docker run -d -p 8080:80 \u0026ndash;name nginx nginx:latest.  docker run -d -p 8080:80 --name nginx nginx\\:latest   -d: Chạy container ở chế độ ngầm\n  Đặt tên cho container là nginx\n  -p 8080:80: Expose cổng 80 của container ra cổng 8080 của máy host\n  nginx:latest: Container được khởi chạy từ image là nginx:latest\n  Lệnh tham khảo để chạy một container:\n  docker run [OPTIONS] IMAGE [COMMAND] [ARG...] Kiểm tra các container nginx đang chạy bằng lệnh:  docker ps  Để thực hiện liệt kê các container ta thực hiện lệnh:  docker ps [OPTIONS] Sử dụng lệnh curl http://localhost:8080 để sử dụng nginx container và xác thực nó đang hoạt động với index.html  curl http://localhost:8080  Tham khảo lệnh curl cơ bản:  curl [options/URLs] \rNgoài ra bạn có thể đọc thêm về CURL\n\rĐể xem nhật ký của nginx và container.   Chúng ta sử dụng lệnh docker logs nginx. Xuất hiện sự kiện curl request  docker logs nginx  Tham khảo lệnh tìm nạp nhật ký của container:   docker logs [OPTIONS] CONTAINER Tiếp đến, thực hiện lệnh docker exec -it nginx /bin/bash để tương tác với container filesystem và constraints  docker exec -it nginx /bin/bash  Tham khảo lệnh tương tác trong container đang chạy:  docker exec [OPTIONS] CONTAINER COMMAND [ARG...] Chúng ta thực hiện xem nội dung của nginx bằng lệnh:  cd /usr/share/nginx/html\rcat index.html Sử dụng exit để thoát khỏi  Để dừng chạy container chúng ta thực hiện lệnh  docker stop nginx  Tham khảo lệnh dừng một hoặc nhiều container:  docker stop [OPTIONS] CONTAINER [CONTAINER...] Sử dụng docker ps -a để xem container (container đã dừng) để khởi động lại sử dụng lệnh: docker start nginx  docker ps -a Thực hiện xóa container (đầu vào là container ID hoặc container name)  docker rm nginx  Tham khảo lệnh xóa một hoặc nhiều container:  docker rm [OPTIONS] CONTAINER [CONTAINER...] Thực hiện xóa nginx image bằng lệnh (định dạng image được xóa có thể là name:tag hoặc IMAGE ID)  docker rmi nginx\\:latest  Tham khảo lệnh xóa một hoặc nhiều image:   docker rmi [OPTIONS] IMAGE [IMAGE...] "
},
{
	"uri": "/vi/1-introduce/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Tổng quan Docker là nền tảng phần mềm cho phép bạn dựng, kiểm thử và triển khai ứng dụng một cách nhanh chóng. Docker đóng gói phần mềm vào các đơn vị tiêu chuẩn hóa được gọi là container có mọi thứ mà phần mềm cần để chạy, trong đó có thư viện, công cụ hệ thống, mã và thời gian chạy. Bằng cách sử dụng Docker, bạn có thể nhanh chóng triển khai và thay đổi quy mô ứng dụng vào bất kỳ môi trường nào và biết chắc rằng mã của bạn sẽ chạy được. Việc chạy Docker trên AWS đem đến cho các nhà phát triển và quản trị viên một phương thức dựng, vận chuyển và chạy ứng dụng phân phối ở quy mô bất kỳ có chi phí thấp và độ tin cậy cao.\nDocker hợp tác với AWS để hỗ trợ các nhà phát triển nhanh chóng đưa ứng dụng hiện đại lên đám mây. Sự hợp tác này giúp nhà phát triển sử dụng Docker Compose và Docker Desktop để tận dụng cùng một quy trình làm việc cục bộ mà họ sử dụng ngày nay để triển khai các ứng dụng trên Amazon ECS và AWS Fargate một cách liền mạch.\n\rCách thức hoạt động của Docker Docker hoạt động bằng cách cung cấp phương thức tiêu chuẩn để chạy mã của bạn. Docker là hệ điều hành dành cho container. Cũng tương tự như cách máy ảo ảo hóa (loại bỏ nhu cầu quản lý trực tiếp) phần cứng máy chủ, các container sẽ ảo hóa hệ điều hành của máy chủ. Docker được cài đặt trên từng máy chủ và cung cấp các lệnh đơn giản mà bạn có thể sử dụng để dựng, khởi động hoặc dừng container.\nCác dịch vụ AWS như AWS Fargate, Amazon ECS, Amazon EKS và AWS Batch giúp bạn dễ dàng chạy các container Docker ở quy mô lớn.\nTrong bài lab, chúng ta sẽ thực hiện chuyển Monolith sang Microservices với Docker và AWS Fargate\n"
},
{
	"uri": "/vi/4-monolith/4.1-checkcloudformation/",
	"title": "Kiểm tra CloudFormation",
	"tags": [],
	"description": "",
	"content": "Kiểm tra CloudFormation  Truy cập vào CloudFormation   Chọn stack đã tạo Chọn Outputs Chọn S3WebsiteURL  Sử dụng trình duyệt truy cập vào S3WebsiteURL.  Giới thiệu về website Mythical Mysfits Mythical Mysfits là một tổ chức phi lợi nhuận nhận nuôi thú cưng (hư cấu) chuyên giúp đỡ những sinh vật thần thoại bị bỏ rơi và thường bị hiểu lầm tìm thấy một gia đình mãi mãi mới! Mythical Mysfits tin rằng tất cả các sinh vật đều xứng đáng có cơ hội thứ hai, ngay cả khi chúng dành cơ hội đầu tiên để trốn dưới gầm cầu và cướp đi những hành động bất lực một cách vô cớ.\nCông việc kinh doanh của chúng tôi đã phát triển mạnh chỉ với một trung tâm nhận con nuôi Mysfits duy nhất, nằm bên trong Đài tưởng niệm Quốc gia Devil Tower. Nói chuyện, bạn bè và tham gia nếu bạn đến thăm.\nChúng tôi vừa có một loạt những điều thần bí mới đến trước cửa nhà chúng tôi mà không còn nơi nào khác để đi! Tất cả họ đều khá quẫn trí sau khi không chỉ bị đuổi khỏi nhà của họ \u0026hellip; mà một con yêu tinh vô cùng gắt gỏng cũng đã từ chối tất cả sự nhập cảnh của họ tại một đầm lầy mà họ từng làm nơi ẩn náu trong quá khứ.\nĐó là lý do tại sao chúng tôi đã thuê bạn làm Full Stack Engineer của chúng tôi. Chúng tôi cần một cách có thể mở rộng hơn để giới thiệu kho bí ẩn của chúng tôi và để các gia đình áp dụng chúng. Chúng tôi muốn bạn xây dựng trang web tiếp nhận Mythical Mysfits đầu tiên để giúp giới thiệu những sinh vật đáng yêu, kỳ diệu, thường tinh nghịch này với thế giới!\n"
},
{
	"uri": "/vi/",
	"title": "Monolith to Microservices with Docker and AWS Fargate",
	"tags": [],
	"description": "",
	"content": "Monolith to Microservices with Docker and AWS Fargate Tổng quan Docker là nền tảng phần mềm cho phép bạn dựng, kiểm thử và triển khai ứng dụng một cách nhanh chóng. Docker đóng gói phần mềm vào các đơn vị tiêu chuẩn hóa được gọi là container có mọi thứ mà phần mềm cần để chạy, trong đó có thư viện, công cụ hệ thống, mã và thời gian chạy. Bằng cách sử dụng Docker, bạn có thể nhanh chóng triển khai và thay đổi quy mô ứng dụng vào bất kỳ môi trường nào và biết chắc rằng mã của bạn sẽ chạy được. Việc chạy Docker trên AWS đem đến cho các nhà phát triển và quản trị viên một phương thức dựng, vận chuyển và chạy ứng dụng phân phối ở quy mô bất kỳ có chi phí thấp và độ tin cậy cao.\nDocker hợp tác với AWS để hỗ trợ các nhà phát triển nhanh chóng đưa ứng dụng hiện đại lên đám mây. Sự hợp tác này giúp nhà phát triển sử dụng Docker Compose và Docker Desktop để tận dụng cùng một quy trình làm việc cục bộ mà họ sử dụng ngày nay để triển khai các ứng dụng trên Amazon ECS và AWS Fargate một cách liền mạch.\n\rCách thức hoạt động của Docker Docker hoạt động bằng cách cung cấp phương thức tiêu chuẩn để chạy mã của bạn. Docker là hệ điều hành dành cho container. Cũng tương tự như cách máy ảo ảo hóa (loại bỏ nhu cầu quản lý trực tiếp) phần cứng máy chủ, các container sẽ ảo hóa hệ điều hành của máy chủ. Docker được cài đặt trên từng máy chủ và cung cấp các lệnh đơn giản mà bạn có thể sử dụng để dựng, khởi động hoặc dừng container.\nCác dịch vụ AWS như AWS Fargate, Amazon ECS, Amazon EKS và AWS Batch giúp bạn dễ dàng chạy các container Docker ở quy mô lớn.\nTrong bài lab, chúng ta sẽ thực hiện chuyển Monolith sang Microservices với Docker và AWS Fargate\n"
},
{
	"uri": "/vi/7-microservices/7.1-createnewrevision/",
	"title": "Tạo Revision",
	"tags": [],
	"description": "",
	"content": "Tạo Revision  Bước đầu tiên, chúng ta thêm một số glue code trong monolith để chuyển like function thành một dịch vụ riêng (microservice). Trong bài lab, sử dụng Cloud9 và tìm app/monolith-service/service/mythicalMysfitsService.py file. Sau đó thực hiện bỏ bình luận phần code sau:  # @app.route(\u0026#34;/mysfits/\u0026lt;mysfit_id\u0026gt;/fulfill-like\u0026#34;, methods=[\u0026#39;POST\u0026#39;])\r# def fulfillLikeMysfit(mysfit_id):\r# serviceResponse = mysfitsTableClient.likeMysfit(mysfit_id)\r# flaskResponse = Response(serviceResponse)\r# flaskResponse.headers[\u0026#34;Content-Type\u0026#34;] = \u0026#34;application/json\u0026#34;\r# return flaskResponse Với tính năng mới được thêm vào monolith, chúng ta thực hiện rebuild monolith docker image với tag mới (nolike).   cd ~/environment/amazon-ecs-mythicalmysfits-workshop/workshop-1/app/monolith-service\rMONO_ECR_REPOSITORY_URI=$(aws ecr describe-repositories | jq -r .repositories[].repositoryUri | grep mono)\rdocker build -t monolith-service:nolike . Thực hiện push monolith docker image lên ECR   Cách tốt nhất là tránh tag latest, có thể không rõ ràng. Thay vào đó, hãy chọn một tag duy nhất , tên mô tả hoặc người dùng tốt hơn là Git SHA và / hoặc ID phiên bản).   docker tag monolith-service:nolike $MONO_ECR_REPOSITORY_URI:nolike\rdocker push $MONO_ECR_REPOSITORY_URI:nolike Thực hiện kiểm tra monolith docker image đã được push lên ECR chưa?   Truy cập vào ECS Chọn Task Definitions Chọn Monolith-Definitions-STACK_NAME (lưu các bạn có thể khác trong hình vì phần sau phụ thuộc vào STACK_NAME mà bạn đặt)  Sau đó, chọn Monolith-Definition-STACK_NAME revision 2.   Chọn Create new revision  Truy cập vào ECR để xem các repository. Bây giờ, trong phần Images đã xuất hiện 2 image với 2 tag là latest và nolike.   Sao chép Image URI  Sử dụng Image URI tag nolike tạo New revision   Thực hiện cấu hình Container Thay Image URI bằng Image URI tag nolike  Chọn Create  Hoàn thành tạo Monolith-Definition-STACK_NAME revision 3.  "
},
{
	"uri": "/vi/2-prerequiste/2.1-createcloudformation/",
	"title": "Tạo Stack CloudFormation",
	"tags": [],
	"description": "",
	"content": "Tạo Stack CloudFormation  Truy cập vào Deploy to AWS để tiến hành tạo stack.  Ngoài ra, bạn cũng có thể tạo Stack CloudFormation với bằng cách Upload file yaml\n\r Bước đầu tiên, cấu hình template. Chọn Template is ready Template source, chọn Amazon S3 URL Trong bài lab, đã cấu hình sẵn Amazon S3 URL Chọn Next  Chúng ta cấu hình chi tiết stack   Stack name, nhập tên stack mà bạn muốn đặt.  STACK_NAME sẽ được sử dụng làm mào đầu hoặc mào cuối của tên của các dịch vụ trong bài lab này. Ví dụ: alb-STACK_NAME-XXX\n\r Trong phần Parameters, chọn false cho SkipBucket Chọn Next  Tiến hành Configure stack options   Tags, nhập giá trị key-value (bạn nhập tùy ý)  Chọn Next  Kiểm tra lại cấu hình stack   Chọn I acknowledge that AWS CloudFormation might create IAM resources Chọn Create Stack  Quá trình tạo stack trong khoảng 7 phút.   Chọn stack tạo thành công Chọn Events Xem quá trình tạo stack  Stack này khởi tạo Cloud9 Environment, DynamoDB Table, LoadBalancerDNS, ProfileName, S3WebsiteURL, SiteBucket.\n\rTrong giao diện stack vừa tạo   Chọn Outputs Chọn value là đường dẫn Cloud9 của Key Cloud9Env.  Chúng ta sử dụng AWS Cloud9 làm môi trường phát triển.  Chúng ta sẽ sử dụng Cloud9 Environment này trong suốt cả bài lab. Môi trường AWS Cloud9 do CloudFormation có tên là Project- STACK_NAME\n\rKiểm tra Outputs của stack   Truy cập vào S3 Chọn Buckets Bucket đã được tạo (http://BUCKET_NAME.s3-website.REGION.amazonaws.com/) Trang web tĩnh và được lưu đường dẫn trong workshop-1/cfn-outputs.json  Tiếp theo chúng kiểm tra DynamoDB   Truy cập vào DynamoDB Table mới đã được khởi tạo  Kiểm tra Load Balancers   Truy cập vào EC2 Chọn Load Balancers Kiểm tra kết quả  "
},
{
	"uri": "/vi/2-prerequiste/",
	"title": "Các bước chuẩn bị",
	"tags": [],
	"description": "",
	"content": "Các bước chuẩn bị Trong bài lab, chúng ta sẽ chuẩn bị các tài nguyên bằng CloudFormation để triển khai.\nTài khoản AWS IAM với các đặc quyền nâng cao cho phép bạn tương tác với CloudFormation, IAM, EC2, ECS, ECR, ELB / ALB, VPC, SNS, CloudWatch, Cloud9. Bạn tham khảo thêm về IAM\n\r Tạo CloudFormation Stack Thực hiện cài đặt Tạo SSH Key  "
},
{
	"uri": "/vi/7-microservices/7.2-updateservice/",
	"title": "Cập nhật Service",
	"tags": [],
	"description": "",
	"content": "Cập nhật Service  Tiếp tục, truy cập vào ECS. Chúng ta sẽ tiến hành update service.   Chọn Cluster Chọn Cluster-STACK_NAME  Trong cluster,   Chọn Service Chọn Service hiện có (STACK_NAME-MythicalMonolithService-xxx) Chọn Edit  Thực hiện thay đổi revision mới nhất (revision chúng ta vừa tạo).   Chọn Update  Như vậy, chúng ta đã tạo new revision và update service thành công.  Truy cập ECS   Chọn Cluster Chọn Service Chọn Monolith-Definition-STACK_NAME revision 3.  Trong giao diện Cluster-STACK_NAME   Chọn Task Chọn Monolith-Definition-STACK_NAME revision 3.  Kiểm tra Logs  "
},
{
	"uri": "/vi/2-prerequiste/2.2-setup/",
	"title": "Clone Repository",
	"tags": [],
	"description": "",
	"content": "Clone Repository  Tiến hành clone Mythical Mysfits Workshop Repository   Trong giao diện Cloud9 IDE, chúng ta sử dụng lệnh sau để clone repository:  git clone https://github.com/aws-samples/amazon-ecs-mythicalmysfits-workshop.git Sau khi clone repository, thay đổi đường dẫn của thư mục:  cd amazon-ecs-mythicalmysfits-workshop/workshop-1 Chúng ta thực hiện dòng lệnh sau để tiến hành cài đặt môi trường chuẩn bị cho bài lab.  script/setup  Đoạn script này sẽ xóa đi Docker images không cần thiết để giải phóng dung lượng. Đồng thời điền vào bảng DynamoDB dữ liệu gốc. Tải nội dung web lên S3. Cài đặt một số cơ chế xác thực liên quan đến Docker.  #! /bin/bash\rset -eu\recho \u0026#34;Removing unneeded docker images...\u0026#34;\rdocker images -q | xargs docker rmi || true\recho \u0026#34;Installing dependencies...\u0026#34;\rsudo yum install -y jq\recho \u0026#34;Fetching CloudFormation outputs...\u0026#34;\rscript/fetch-outputs\recho \u0026#34;Populating DynamoDB table...\u0026#34;\rscript/load-ddb\recho \u0026#34;Uploading static site to S3...\u0026#34;\rif [[ $# -eq 1 ]]; then\rscript/upload-site $1\relse\rscript/upload-site\rfi\recho \u0026#34;Installing ECR Cred Helper...\u0026#34;\rsudo script/credhelper\recho \u0026#34;Attaching Instance Profile to Cloud9...\u0026#34;\rscript/associate-profile\recho \u0026#34;Success!\u0026#34; Khi bạn thấy trên giao diện hiển thị \u0026ldquo;Success!\u0026rdquo; là thực thi lệnh thành công.  Kiểm tra trong giao diện S3   Trong bucket đã được upload các tệp website  Kiểm tra trong giao diện DynamoDB   Dữ liệu gốc đã được điền vào Table DynamoDB  Chúng ta nên cấu hình aws cli với current region của chúng ta làm mặc định:  export ACCOUNT_ID=$(aws sts get-caller-identity --output text --query Account)\rexport AWS_REGION=$(curl -s 169.254.169.254/latest/dynamic/instance-identity/document | jq -r \u0026#39;.region\u0026#39;)\recho \u0026#34;export ACCOUNT_ID=${ACCOUNT_ID}\u0026#34; \u0026gt;\u0026gt; ~/.bash_profile\recho \u0026#34;export AWS_REGION=${AWS_REGION}\u0026#34; \u0026gt;\u0026gt; ~/.bash_profile\raws configure set default.region ${AWS_REGION}\raws configure get default.region "
},
{
	"uri": "/vi/3-containersanddocker/3.2-containerimage/",
	"title": "Container image",
	"tags": [],
	"description": "",
	"content": "Thực hiện xây dựng container image Trong phần này chúng ta thực hiện build container image. Làm việc với Dockerfile.\nDockerfile là một file dạng text không có phần đuôi mở rộng, chứa các đặc tả về một trường thực thi phần mềm, cấu trúc cho Docker Image. Từ những câu lệnh đó, Docker sẽ build ra Docker image (thường có dung lượng nhỏ từ vài MB đến lớn vài GB).\nTổng quan về Dockerfile Cú pháp chung của một Dockerfile\nINSTRUCTION arguments  INSTRUCTION là tên các chỉ thị có trong Dockerfile, mỗi chỉ thị thực hiện một nhiệm vụ nhất định, được Docker quy định. Khi khai báo các chỉ thị này phải được viết bằng chữ IN HOA. Một Dockerfile bắt buộc phải bắt đầu bằng chỉ thị FROM để khai báo đâu là image sẽ được sử dụng làm nền để xây dựng nên image của bạn. arguments là phần nội dung của các chỉ thị, quyết định chỉ thị sẽ làm gì.  Một số chỉ thị trong Dockerfile FROM\nFROM \u0026lt;image\u0026gt; [AS \u0026lt;name\u0026gt;]\rFROM \u0026lt;image\u0026gt;[:\u0026lt;tag\u0026gt;] [AS \u0026lt;name\u0026gt;]\rFROM \u0026lt;image\u0026gt;[@\u0026lt;digest\u0026gt;] [AS \u0026lt;name\u0026gt;] LABEL\nLABEL \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; ... \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; MAINTAINER\nMAINTAINER \u0026lt;name\u0026gt; [\u0026lt;email\u0026gt;] RUN\nRUN \u0026lt;command\u0026gt; ADD\nADD [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt;\rADD [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] [\u0026#34;\u0026lt;src\u0026gt;\u0026#34;,... \u0026#34;\u0026lt;dest\u0026gt;\u0026#34;] COPY\nCOPY [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt;\rCOPY [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] [\u0026#34;\u0026lt;src\u0026gt;\u0026#34;,... \u0026#34;\u0026lt;dest\u0026gt;\u0026#34;] ENV\nENV \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; ... CMD Dùng để cung cấp câu lệnh mặc định sẽ được chạy khi Docker Container khởi động từ Image đã build, chỉ có thể có duy nhất 1 chỉ thị CMD.\nThực hành  Tạo thư mục cho container image  mkdir ~/environment/container-image Nhập cd container-image để thay đổi vào thư mục đó.  cd ~/environment/container-image Chạy touch Dockerfile để tạo Dockerfile. Tệp này sẽ chứa một tập hợp các bước cần thiết để xây dựng container image.  touch Dockerfile Chạy lệnh dưới đây để cập nhật nội dung Dockerfile  cat \u0026lt;\u0026lt;EOF \u0026gt; Dockerfile\rFROM nginx\\:latest\rCOPY index.html /usr/share/nginx/html\rEOF Chạy touch index.html để tạo một tệp html trống sẽ chứa một thông báo đơn giản.  touch index.html Sử dụng echo để chuyển một thông báo đơn giản vào tệp index.html  echo \u0026#34;We\u0026#39;ve added our own custom content into the container\u0026#34; \u0026gt;\u0026gt; index.html Sử dụng docker build -t nginx:1.0 . để xây dựng container image nginx từ Dockerfile.  docker build -t nginx:1.0 .  Tham khảo lệnh build image từ một Dockerfile  docker build [OPTIONS] PATH | URL | - Sử dụng docker history nginx:1.0 để xem tất cả các bước và base container.  docker history nginx:1.0  Tham khảo lệnh xem lịch sử của một image:  docker history [OPTIONS] IMAGE Sử dụng lệnh docker run -p 8080:80 \u0026ndash;name nginx nginx:1.0 để chạy container ( không sử dụng chế độ chạy ngầm nhằm dễ dàng gỡ lỗi)  docker run -p 8080:80 --name nginx nginx:1.0 Mở một tab Terminal khác ( Window -\u0026gt; New Terminal ). Chạy curl http://localhost:8080 trong tab một vài lần và xem nội dung mới.  curl http://localhost:8080 Quay lại tab đầu tiên và xem các dòng nhật ký được gửi ngay đến STDOUT. Gõ Ctrl-C để thoát khỏi đầu ra nhật ký. Lưu ý rằng container đã được dừng lại nhưng vẫn ở đó khi chạy docker ps -a.  Sử dụng docker ps -a  docker ps -a Sử dụng sudo docker inspect nginx để xem thông tin chi tiết về container đã dừng.  sudo docker inspect nginx Sử dụng docker rm nginx để xóa container  docker rm nginx Gắn một số tệp từ máy chủ lưu trữ vào container thay vì nhúng chúng vào image.  docker run -d -p 8080:80 -v /home/ec2-user/environment/container-image/index.html:/usr/share/nginx/html/index.html\\:ro --name nginx nginx\\:latest Thực hiện curl http://localhost:8080. Lưu ý rằng mặc dù đây là upstream nginx image từ Docker Hub nhưng nội dung có ở đó.  curl http://localhost:8080 Chỉnh sửa tệp index.html  echo \u0026#34;This is another line I\u0026#39;ve added to my container\u0026#34; \u0026gt;\u0026gt; index.html Thử lại curl http://localhost:8080  curl http://localhost:8080 Cuối cùng, chạy docker stop nginx và docker rm nginx dừng và loại bỏ container  docker stop nginx \u0026amp;\u0026amp; docker rm nginx "
},
{
	"uri": "/vi/4-monolith/4.2-mythicalmysfitsmonolith/",
	"title": "Containerize the Mythical Mysfits monolith",
	"tags": [],
	"description": "",
	"content": "Containerize the Mythical Mysfits monolith Ý nghĩa của một số INSTRUCTION trong Dockerfile.  FROM: Dùng để chỉ ra image được build từ image gốc nào. Tùy vào mỗi ứng dụng cần đóng gói mà chúng ta sẽ sử dụng image gốc khác nhau. RUN: Dùng để chạy một lệnh nào đó khi build image. WORKDIR: Dùng để thiết lập thư mục làm việc. Mọi chỉ thị RUN, CMD, ENTRYPOINT, COPY và ADD sau đó đều sẽ diễn ra bên trong thư mục WORKDIR này. COPY: COPY thư mục nguồn từ máy host vào filesystem của image. CMD: Dùng để cung cấp câu lệnh mặc định sẽ được chạy khi Docker Container khởi động từ Image đã build, chỉ có thể có duy nhất 1 chỉ thị CMD.   Kiểm tra Dockerfile.draft  FROM ubuntu:20.04\rRUN apt-get update -y\rRUN apt-get install -y python3-pip python-dev build-essential\rRUN pip3 install --upgrade pip\r#[TODO]: Copy python source files and requirements file into container image\r#[TODO]: Install dependencies listed in the requirements.txt file using pip3\r#[TODO]: Specify a listening port for the container\r#[TODO]: Run mythicalMysfitsService.py as the final step. We want this container to run as an executable. Looking at ENTRYPOINT and CMD for this? Hoàn thành Dockerfile  FROM ubuntu:20.04\rRUN apt-get update -y\rRUN apt-get install -y python3-pip python-dev build-essential\rRUN pip3 install --upgrade pip\r#[TODO]: Copy python source files and requirements file into container image\rCOPY ./service /MythicalMysfitsService\rWORKDIR /MythicalMysfitsService\r#[TODO]: Install dependencies listed in the requirements.txt file using pip3\rRUN pip3 install -r ./requirements.txt\r#[TODO]: Specify a listening port for the container\rEXPOSE 80\r#[TODO]: Run the mythicalMysfitsService.py as the final step\rENTRYPOINT [\u0026#34;python3\u0026#34;]\rCMD [\u0026#34;mythicalMysfitsService.py\u0026#34;] Nếu Dockerfile hoàn thành, hãy đổi tên tệp của bạn từ \u0026ldquo;Dockerfile.draft\u0026rdquo; thành \u0026ldquo;Dockerfile\u0026rdquo; và tiếp tục bước tiếp theo.  cd ~/environment/amazon-ecs-mythicalmysfits-workshop/workshop-1/app/monolith-service/\rmv Dockerfile.draft Dockerfile Thực hiện build image bằng lệnh docker build [OPTIONS] PATH | URL | - .  Lệnh này cần được chạy trong cùng thư mục chứa Dockerfile của bạn.\n\r Lưu ý khoảng thời gian sau đó cho lệnh xây dựng tìm trong thư mục hiện tại cho Dockerfile.  docker build -t monolith-service . Bạn sẽ thấy một loạt kết quả khi Docker build tất cả các layer của image.  Nếu có sự cố xảy ra trong quá trình build, quá trình build sẽ không thành công và dừng lại (văn bản màu đỏ và các cảnh báo trên đường đi cũng được miễn là quá trình build không bị lỗi).\n\rRemoving intermediate container a71540b615b4\r---\u0026gt; 5ab93ce927c8\rStep 8/10 : EXPOSE 80\r---\u0026gt; Running in 27074f1d4c3a\rRemoving intermediate container 27074f1d4c3a\r---\u0026gt; f528fe7756d5\rStep 9/10 : ENTRYPOINT [\u0026#34;python3\u0026#34;]\r---\u0026gt; Running in 8ef1757aadb0\rRemoving intermediate container 8ef1757aadb0\r---\u0026gt; a1d1ed159fb2\rStep 10/10 : CMD [\u0026#34;mythicalMysfitsService.py\u0026#34;]\r---\u0026gt; Running in da0c544e601b\rRemoving intermediate container da0c544e601b\r---\u0026gt; b283e0821fc9\rSuccessfully built b283e0821fc9\rSuccessfully tagged monolith-service:latest Dockerfile của bạn đã được tạo thành công, nhưng chưa tối ưu hóa Dockefile cho microservices.  Vì bạn chuyển monolith thành các microservices, bạn sẽ chỉnh sửa source code (ví dụ mythicalMysfitsService.py) và build image này một vài lần.\n\r Kiểm tra Dockerfile  Thực hiện tối ưu Dockerfile  FROM ubuntu:20.04\rRUN apt-get update -y\rRUN apt-get install -y python3-pip python-dev build-essential\rRUN pip3 install --upgrade pip\rCOPY ./service/requirements.txt .\rRUN pip3 install -r ./requirements.txt\rCOPY ./service /MythicalMysfitsService\rWORKDIR /MythicalMysfitsService\rEXPOSE 80\rENTRYPOINT [\u0026#34;python3\u0026#34;]\rCMD [\u0026#34;mythicalMysfitsService.py\u0026#34;] Để thấy được lợi ích của việc tối ưu hóa Dockerfile, trước tiên bạn cần phải rebuild monolith image bằng cách sử dụng Dockerfile mới.  docker build -t monolith-service . Sau đó, chúng ta thực hiện thay đổi mythicalMysfitsService.py bằng cách thêm 1 câu bình luận ở cuối file.  # This is a comment to force a Docker-rebuild Docker đã lưu vào bộ nhớ cache các yêu cầu trong lần build lại đầu tiên sau khi sắp xếp lại.  docker build -t monolith-service .  Thực hiện rebuild monolith image một lần nữa. Tham chiếu bộ nhớ cache trong lần build lại thứ hai này   Sử dụng docker images [OPTIONS] [REPOSITORY[:TAG]] để liệt kê danh sách image\n  docker images Chạy container và kiểm tra  TABLE_NAME=$(aws dynamodb list-tables | jq -r .TableNames[0])\rdocker run -p 8000:80 -e AWS_DEFAULT_REGION=$AWS_REGION -e DDB_TABLE_NAME=$TABLE_NAME monolith-service \rLưu ý: Bạn có thể tìm thấy tên bảng DynamoDB của mình trong tệp workshop-1/cfn-output.json có nguồn gốc từ kết quả đầu ra của CloudFormation Stack\n\rĐể kiểm tra chức năng cơ bản của dịch vụ monolith, hãy truy vấn dịch vụ bằng tiện ích như cURL đi kèm với Cloud9.   Nhấp vào dấu cộng bên cạnh các tab của bạn và chọn New Terminal hoặc nhấp vào Window -\u0026gt; New Terminal từ menu Cloud9 để mở một phiên shell mới để chạy lệnh curl sau.  curl http://localhost:8000/mysfits  Bạn sẽ thấy một mảng JSON với dữ liệu về Mythical Mysfits  Lưu ý: Các quy trình chạy bên trong vùng chứa Docker có thể xác thực bằng DynamoDB vì chúng có thể truy cập điểm cuối API siêu dữ liệu EC2 đang chạy tại 169.254.169.254để truy xuất thông tin đăng nhập cho hồ sơ cá thể đã được đính kèm với môi trường Cloud9 của chúng tôi trong tập lệnh thiết lập ban đầu. Các quy trình trong vùng chứa không thể truy cập tệp ~/.aws/credentials trong hệ thống tệp máy chủ (trừ khi nó được gắn vào vùng chứa một cách rõ ràng).\n\rQuay trợ lại tab chạy monolith container   Monolith container chạy trên nền trước với tính năng stdout/stderr in ra màn hình, khi nhận được request, sẽ hiện thị 200 \u0026ldquo;OK\u0026rdquo;   * Serving Flask app \u0026#34;mythicalMysfitsService\u0026#34; (lazy loading)\r* Environment: production\rWARNING: This is a development server. Do not use it in a production deployment.\rUse a production WSGI server instead.\r* Debug mode: off\r* Running on http://0.0.0.0:80/ (Press CTRL+C to quit)\r172.17.0.1 - - [26/May/2022 16:49:43] \u0026#34;GET /mysfits HTTP/1.1\u0026#34; 200 -\rINFO:werkzeug:172.17.0.1 - - [26/May/2022 16:49:43] \u0026#34;GET /mysfits HTTP/1.1\u0026#34; 200 - Trong tab chạy monolith container, sử dụng tổ hợp phím Ctrl + C để dừng chạy container.  Lưu ý: Container chạy ở foreground với tính năng stdout / stderr in vào bảng điều khiển. Trong môi trường production, khi chạy container trong background và phải cấu hình điểm đến của logs. Chúng ta có thể chạy container trong background (chạy ngầm) bằng cách sử dụng -d.\n\rTABLE_NAME=$(aws dynamodb list-tables | jq -r .TableNames[0])\rdocker run -d -p 8000:80 -e AWS_DEFAULT_REGION=$AWS_REGION -e DDB_TABLE_NAME=$TABLE_NAME monolith-service Liệt kê danh sách docker container để kiểm tra container đang chạy  docker ps Xem monolith đang chạy trong danh sách (lưu trữ Container ID để sử dụng docker logs). Lặp lại lệnh curl, sau đó thực hiện kiểm tra logs  docker logs \u0026lt;CONTAINER_ID\u0026gt; Hiện tại, chúng ta đang có Docker image đang hoạt động, ta thực hiện gán tag và push vào ECR. AWS ECR là một dịch vụ Docker container registry quản lý hoàn toàn bởi AWS nhằm đơn giản hóa việc lưu trữ, quản lý và triển khai các Docker container image. ECR có thể tích hợp được với Amazon Elastic Container Service (ECS) nhằm đơn giản hóa việc thiết lập luồng thực hiện triển khai cho các hệ thống production cũng như loại bỏ đi sự phức tạp trong việc quản lý kho lưu trữ cho các container image. Trong kế tiếp, ta sử dụng ECS pull image từ ECR.   Truy cập vào ECS và chọn Repositories Chúng ta sẽ có 2 repository: STACK_NAME-mono-xxx và STACK_NAME-like-xxx Chọn vào icon sao chép URL của Mono repository( sử dụng trong các bước tiếp)  Note: repository URI là duy nhất\n\rThực hiện gán tag và push container image và monolith repository  MONO_ECR_REPOSITORY_URI=$(aws ecr describe-repositories | jq -r .repositories[].repositoryUri | grep mono)\rdocker tag monolith-service:latest $MONO_ECR_REPOSITORY_URI:latest\rdocker push $MONO_ECR_REPOSITORY_URI:latest Truy cập vào trang ECR repository, đã xuất hiện image được upload và tagged là latest.  "
},
{
	"uri": "/vi/7-microservices/7.3-builddockerimage/",
	"title": "Build Docker Image",
	"tags": [],
	"description": "",
	"content": " Truy cập vào ECR   Chọn Repository Xuất 2 repository STACK_NAME-like-XXX và STACK_NAME-mono-XXX  Bây giờ sẽ build like service   cd ~/environment/amazon-ecs-mythicalmysfits-workshop/workshop-1/app/like-service\rLIKE_ECR_REPOSITORY_URI=$(aws ecr describe-repositories | jq -r .repositories[].repositoryUri | grep like)\rdocker build -t like-service . Thực hiện build docker image thành công sau đó push lên ECR với tag latest.   docker tag like-service:latest $LIKE_ECR_REPOSITORY_URI:latest\rdocker push $LIKE_ECR_REPOSITORY_URI:latest Thực hiện push thành công.  Kiểm tra image đã được push trong STACK_NAME-like-XXX  "
},
{
	"uri": "/vi/3-containersanddocker/",
	"title": "Giới thiệu Docker và Container",
	"tags": [],
	"description": "",
	"content": "Giới thiệu Docker và Container Trong phần này, chúng ta sẽ thực hành một số lệnh cơ bản về Docker và hiểu khái niệm về Container.\nChạy Docker trên AWS AWS cung cấp hỗ trợ cho cả giải pháp mã nguồn mở lẫn thương mại của Docker. Có nhiều cách chạy container trên AWS, trong đó có Amazon Elastic Container Service (ECS) là dịch vụ quản lý container có quy mô cực kỳ linh hoạt và hiệu năng cao. Khách hàng có thể dễ dàng triển khai ứng dụng đã đưa vào container của mình từ môi trường Docker cục bộ lên thẳng Amazon ECS.\nAWS Fargate là công nghệ dành cho Amazon ECS cho phép bạn chạy container trong sản xuất mà không cần triển khai hoặc quản lý cơ sở hạ tầng. AWS Fargate là công nghệ dành cho Amazon ECS cho phép bạn chạy container mà không cần cung cấp hay quản lý máy chủ.\nAmazon Elastic Container Registry (ECR) là kho container riêng bảo mật và có độ sẵn sàng cao giúp việc lưu trữ và quản lý ảnh container Docker của bạn trở nên dễ dàng, mã hóa và nén image khi lưu trữ để quá trình bung diễn ra nhanh chóng và bảo mật.\nNội dung  Docker cơ bản Container image  "
},
{
	"uri": "/vi/2-prerequiste/2.3-createanssh/",
	"title": "Tạo SSH Key",
	"tags": [],
	"description": "",
	"content": "Tạo SSH key  Chúng ta thực hiện lệnh để generate SSH key trong Cloud9. Key này sẽ được sử dụng truy cập vào node instance  Chúng ta có thể truy cập bằng lệnh: ssh -i PRIVATE_KEY.PEM ec2-user @ EC2_PUBLIC_DNS_NAME\n\rssh-keygen Chúng ta thực hiện upload public key vào EC2 region  aws ec2 import-key-pair --key-name \u0026#34;mythicaleks\u0026#34; --public-key-material file://~/.ssh/id_rsa.pub \rNếu gặp lỗi An error occurred (InvalidKey.Format) when calling the ImportKeyPair operation: Key is not in valid OpenSSH public key format, bạn có thể thử lệnh sau:\n\raws ec2 import-key-pair --key-name \u0026#34;mythicaleks\u0026#34; --public-key-material fileb://~/.ssh/id_rsa.pub Truy cập vào EC2   Chọn Key pair Xem key đã được upload vào EC2 region  "
},
{
	"uri": "/vi/4-monolith/",
	"title": "Containerize monolith",
	"tags": [],
	"description": "",
	"content": "Containerize the Mythical Mysfits monolith  Kiểm tra CloudFormation Containerize the Mythical Mysfits monolith  "
},
{
	"uri": "/vi/7-microservices/7.4-createtaskdefinition/",
	"title": "Tạo Task Definition",
	"tags": [],
	"description": "",
	"content": "Tạo Task Definition  Thực hiện tạo Task Definition cho like service sử dụng image đã push lên ECR.   Trong giao diện ECS, chọn Task definitions Chọn Create new task definition  Tiến hành cấu hình Task definition   Đặt Task definition family, nhập Microservice-Definition-STACK_NAME  Chúng ta sử dụng image đã push lên ECR trong repository STACK_NAME-like-XXX   Like service code được thiết kế gọi endpoint trên monolith để duy trì dữ liệu với DynamoDB. Tham chiếu giá trị của môi trường MONOLITH_URL. Chúng ta sẽ tạo môi trường với Key là MONOLITH_URL và Value là ALB(cụ thể là alb-STACK_NAME-XXX) Chọn Next  Thực hiện cấu hình môi trường   Chúng ta sử dụng AWS Fargate Operating system là Linux Bạn có thể tùy chỉnh Task size Chọn Task role, chọn STACK_NAME-EcsServiceRole-XXX  Sử dụng Amazon CloudWatch  Kiểm tra lại và chọn Create  Như vậy, chúng ta đã tạo thành công một Task definition Microservice-Definition-STACK_NAME  "
},
{
	"uri": "/vi/7-microservices/7.5-createecsservice/",
	"title": "Create ECS Service",
	"tags": [],
	"description": "",
	"content": " Cũng trong giao diện Task vừa tạo, chúng ta sẽ tạo một ECS service để chạy Task definition vừa tạo.   Chọn Deploy Chọn Create Sevice  Thiết lập môi trường   Chọn cluster (Cluster-STACK_NAME)  Thực hiện cấu hình Deployment*   Application type, mặc định Service Thực hiện đặt tên Service name Desired tasks, chọn 1  Thực hiện cấu hình Load Balancing   Chọn Application Load Balancer Chọn Use an existing load balancer Chọn alb-STACK_NAME Cấu hình Listener (Port: 8080 và Protocol: HTTP) Tạo Target group, nhập microservice-tg Health check path, nhập / Health check grace period, nhập 300  Cấu hình Network   VPC, chọn Mysfits-STACK_NAME Subnets, chọn private subnet Về Security group, chọn Use an existing security group Ta chọn Security group default và đảm bảo inbound cấu hình HTTP (cổng 80) Chọn Deploy  Như vậy, chúng ta tạo service deploy thành công.  Sau khi Microservice service deploy, chúng ta thực hiện kiểm tra giao diện website và thực hiện test like.   Chọn S3WebsiteURL  Chúng ta sử dụng trình duyệt truy cập vào website. Kiểm tra lại CloudWatch logs và hiển thị \u0026ldquo;Like processed.\u0026rdquo;  Thực hiện bỏ phần endpoint từ monolith bằng cách sử dụng Cloud9.   Trong monolith folder, mở mythicalMysfitsService.py tìm đoạn code sau:  # increment the number of likes for the provided mysfit.\r@app.route(\u0026#34;/mysfits/\u0026lt;mysfit_id\u0026gt;/like\u0026#34;, methods=[\u0026#39;POST\u0026#39;])\rdef likeMysfit(mysfit_id):\rserviceResponse = mysfitsTableClient.likeMysfit(mysfit_id)\rprocess_like_request()\rflaskResponse = Response(serviceResponse)\rflaskResponse.headers[\u0026#34;Content-Type\u0026#34;] = \u0026#34;application/json\u0026#34;\rreturn flaskResponse  Bạn có thể xóa hoặc comment code.  Sau đó, chúng ta thực hiện build monolith image   cd ~/environment/amazon-ecs-mythicalmysfits-workshop/workshop-1/app/monolith-service docker build -t monolith-service:nolike2 . Thực hiện gán tag và push lên monolith ECR repository.   Chúng ta sử dụng tag: nolike2.   docker tag monolith-service:nolike2 $MONO_ECR_REPOSITORY_URI:nolike2\rdocker push $MONO_ECR_REPOSITORY_URI:nolike2 Kiểm tra monolith repository trên ECR, ta sẽ thấy image được push với tag là nolike2.  Bây giờ, hãy tạo một Task Definition cuối cùng cho monolith để tham chiếu đến URI Image Container này và update dịch vụ monolith để sử dụng Task Definition mới và đảm bảo ứng dụng vẫn hoạt động như trước.  "
},
{
	"uri": "/vi/5-amazonecsandawsfargate/",
	"title": "Sử dụng AWS Fargate triển khai container",
	"tags": [],
	"description": "",
	"content": "Deploy the container using AWS Fargate  Bước đầu, chúng ta sẽ tạo Task definitions để chạy monolith   Truy cập ECS Chọn Task definitions Tìm Task definition có tên Monolith-Definition-STACK_NAME  Truy cập vào ECR   Sao chép Image URI  Quay lại giao diện ECS   Chọn Monolith-Definition-STACK_NAME  Trong giao diện Monolith-Definition-STACK_NAME revision 1. Chúng ta sẽ thực hiện tạo một revision mới.   Chọn Create new revision  Tiến hành cấu hình Container   Name, nhập tên service mà bạn chọn(Trong bài lab, nhập monolith-service) Dán Image URI đã sao chép vào Image URI  Chọn Create  Hoàn thành tạo new revision  Trong giao diện Monolith-Definition-STACK_NAME revision 2   Chọn Deploy Chọn Run stask  Trong giao diện Deploy   Environment, chọn Existing cluster, chọn Cluster-STACK_NAME Chọn Launch type Trong Launch type, chọn FARGATE Platform version chọn LATEST  Trong phần Deployment configuration   Chọn Task Desired chọn 1  Tiến hành cấu hình Networking   VPC, chọn Mysfits-VPC-STACK_NAME Subnets chọn Mysfits-PublicOne-STACK_NAME Chọn Security Group, Chọn Use an existing security group Security group name, chọn default nhưng phải cấu hình inbound cổng 80 Auto-assign public IP - \u0026ldquo;ENABLED\u0026rdquo; Chọn Deploy  Tạo task thành công  Chọn task vừa tạo và chọn Networking.   Mục đích sử dụng Public IP để sử dụng lệnh curl kiểm tra bằng cách thực hiện GET request. Khi sử dụng kiểu khởi tạo Fargate, mỗi task sẽ nhận ENI và Public IP và Private IP của riêng nó.  Thực hiện truy cập bằng trình duyệt  http://TASK_PUBLIC_IP_ADDRESS/mysfits Thực hiện lệnh curl trên Cloud9  curl http://TASK_PUBLIC_IP_ADDRESS/mysfits Chọn task vừa tạo và chọn Logs  Sử dụng AWS CloudWatch để xem Log events   Chọn monolith log group (STACK_NAME-MythicalMonolithLogGroup-XXX)  Sau khi chạy lệnh curl thành công ta có thể xóa task   Chọn Task Chọn Monolith-Definition-STACK_NAME revision 2. Chọn Stop Chọn Stop selected  Xác thực Stop và chọn Stop  Xóa task thành công.  "
},
{
	"uri": "/vi/6-alb/",
	"title": "ALB và ECS Service",
	"tags": [],
	"description": "",
	"content": "Scale the adoption platform monolith with an ALB and an ECS Service Phương pháp Run Task đã sử dụng trong phần trước rất tốt để thử nghiệm, nhưng nếu cần chạy nền tảng áp dụng như một quá trình chạy lâu dài. Bạn cần sử dụng Elastic Load Balancing Appliction Load Balancer (ALB) để phân phối các yêu cầu đến các container đang chạy của bạn. Ngoài việc cân bằng tải đơn giản, còn tạo ra các khả năng như định tuyến dựa trên đường dẫn đến các dịch vụ khác nhau.\nECS giúp duy trì số lượng desired task (số container chạy trong thời gian dài) và tích hợp ALB (xử lý việc đăng ký / hủy đăng ký container vào ALB)\nDịch vụ ECS và ALB ban đầu đã được CloudFormation tạo. Trong bài lab này, bạn sẽ cập nhật các tài nguyên đó để lưu trữ monolith service được đóng gói. Sau đó, bạn sẽ tạo một service mới từ đầu sau khi phá vỡ monolith.\n Truy cập vào CloudFormation   Chọn STACK_NAME Chọn Stack details Chọn Outputs Chọn LoadBalancerDNS  Sử dụng trình duyệt truy cập vào LoadBalancerDNS  Truy cập vào ECS   Chọn Clusters Chọn Cluster-STACK_NAME  Trong giao diện Cluster-STACK_NAME, chúng ta tiến hành cập nhật service   Chọn Services Chọn Edit  Trong giao diện cập nhật service   Chọn Revision 2 Chọn Update  Update service thành công.  Trong giao diện Cluster-STACK_NAME   Chọn Task Kiểm tra Monolith-Definition-STACK_NAME đã được cập nhật Revision 2  Truy cập vào CloudFormation   Chọn STACK_NAME Chọn Stack details Chọn Outputs Chọn S3WebsiteURL  Sử dụng trình duyệt để truy cập vào S3WebsiteURL  Thực hiện các thao tác trải nghiệm giao diện người dùng  Truy cập vào ECS   Chọn Cluster Chọn Cluster-STACK_NAME Chọn Tasks Chọn Monolith-Definition-STACK_NAME revision 2  Chọn Logs  Kiểm tra logs để đảm bảo monolith có thể đọc và ghi DynamoDB và có thể xử lý like.  Kiểm tra CloudWatch logs từ ECS để đảm bảo Like processed  Truy cập CloudWatch   Chọn Log groups Quan sát log event  Để phân biệt giữa service và task. Ta có thể thực hiện các bước sau:   Chọn Service Chọn Edit  Nâng số Desired task lên là 3 và update.  Sau khi update thành công.   Chọn Task sẽ thấy 3 task đang chạy. Từ đó, ta thấy ECS services là khái niệm trong đó ECS cho phép chạy và duy trì một số lượng container cụ thể của các task definition trong một ECS cluster. Một service gồm nhiều task và được duy trì.  "
},
{
	"uri": "/vi/7-microservices/",
	"title": "Microservices với AWS Fargate",
	"tags": [],
	"description": "",
	"content": "Microservices với AWS Fargate Trong lab này, chúng ta sẽ thực hiện phá vỡ monolith chuyển thành các microservice.\nMonolith cung cấp tài nguyên API khác nhau trên các định tuyến khác để tìm nạp thông tin về Mysfits, trải nghiệm like hoặc adopt\nLogic của các tài nguyên này bao gồm một số proccess (như đảm bảo rằng người dùng được phép thực hiện một hành động cụ thể, rằng Mysfit đủ điều kiện để áp dụng, v.v.) và thực hiện một số tương tác với persistence layer (cụ thể là DynamoDB).\nThay vì sử dụng nhiều service khác nhau tương tác trực tiếp với một database (thêm index và data migration thì đã khó khăn với 1 application). Vì vậy không tách tất cả logic của tài nguyên ra thành từng service riêng biệt mà chỉ chuyển logic Process sang service riêng và vẫn sử dụng monolith làm tiền đề với database (tức là không chuyển hoàn toàn từ monolith sang microservice mà chỉ chuyển nhưng phần phức tạp).\nALB có một tính năng khác được gọi là path-based routing, định tuyến lưu lượng truy cập dựa trên đường dẫn URL đến các target group. Điều này có nghĩa là bạn sẽ chỉ single instance của ALB duy nhất để lưu trữ các microservice của bạn. Dịch vụ monolith sẽ nhận tất cả lưu lượng truy cập đến đường dẫn mặc định \u0026rsquo;/\u0026rsquo;. Adoption và like service sẽ lần lượt là \u0026rsquo;/ accept\u0026rsquo; và \u0026lsquo;/ like\u0026rsquo;.\nNội dung  Tạo Revision Cập nhật Service Build Docker Image Tạo Task Definition Create ECS Service  "
},
{
	"uri": "/vi/8-cleanup/",
	"title": "Dọn dẹp tài nguyên",
	"tags": [],
	"description": "",
	"content": "Dọn dẹp tài nguyên Xóa ECS service   Mở bảng điều khiển Amazon ECS tại https://console.aws.amazon.com/ecs/.\n  Trên thanh điều hướng, chọn Region có cluster của bạn.\n  Trong ngăn dẫn hướng, hãy chọn Cluster và chọn tên của Cluster liên quan bài lab.\n  Trên trang Cluster, chọn Service\n  Chọn Delete.\n  Xác nhận xóa service.\n  Xóa repository   Truy cập ECR : https://console.aws.amazon.com/ecr/repositories.\n  Chọn Region chứa repository\n  Chọn Repository\n  Chọn Private và chọn các repository liên quan bài lab.\n  Chọn Delete\n  Xóa ALB  Truy cập vào EC2 Chọn Load Balancer Chọn ALB của bài lab. Chọn Actions Chọn Delete  Xóa CloudFormation Stack  Truy cập vào CloudFormation Chọn Stack Chọn stack liên quan bài lab. Chọn Delete  "
},
{
	"uri": "/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]